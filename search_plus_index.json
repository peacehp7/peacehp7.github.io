{"./":{"url":"./","title":"关于本文档","keywords":"","body":"About RMU3.0 Programming Guide 本文档是RMU3.0框架的开发指南，旨在指导读者如何独立在该框架下开发RMU的功能模块。 RMU版本：0.1.1 Draft 作者信息： Hirain Technology ziping.he > 知识储备 读者应该掌握C++(11)开发的基本概念和技能，本文档不是C++教程，一些基础概念不会在此详述。 读者应该了解“什么是RMU框架”。在RMU2.0框架上进行过开发，或者至少阅读过其代码，了解框架包含的基本概念，如loop、module、event、timer等，如果这些名词对你来说很陌生，那么你需要先行掌握一些相关知识。 内容 本文档包括一些RMU3.0框架的常用组件介绍，包括并不限于： module(模块) timer(定时器) fd_watcher(文件描述符监控) event(事件) 其他功能 每个模块的说明包含两部分： 基础使用方法 模块实现原理 对于在RMU框架上进行应用开发的人员，建议至少阅读第1部分，了解各个基础组件的使用方式以及注意事项，避免使用不恰当的组件，或者在使用方式上犯错。 对于要进行框架及基础组件代码优化，或是增加新的基础组件的开发人员，应该阅读第2部分，了解模块的实现原理。 编码风格 RMU3.0遵从Google 开源项目风格指南 - 中文版的编码风格，你可以在该链接找到你需要的全部信息。 在此强调，尽管编码风格是众说纷纭、灵活可变、带有强烈个人好恶的，仍然强烈建议通过自我注意、代码审查等手段维护项目代码风格的统一，这对于项目的可读性、可维护性都具有巨大益处。 "},"abstract/compile_and_run.html":{"url":"abstract/compile_and_run.html","title":"编译和运行","keywords":"","body":"编译和运行 编译和运行 目录结构 编译 运行 目录结构 典型的项目目录如下： . ├── build.sh ├── CMakeLists.txt ├── configs ├── include ├── public ├── README.md ├── scripts ├── src └── toolchain 针对其中的部分内容说明如下： 文件/目录 用途 README.md 说明文件，内含环境要求、编译指令、安装方法等 build.sh 编译脚本，通过执行此脚本编译RMU configs 用于存放配置数据库文件config_xxx.sqlite include 所有头文件都放置在include中 public 用于存放公共events文件，用于RMU进程间的事件交互 scripts 用于存放脚本性质的文件 src 所有的.cc和.c文件 toolchain 用于存放交叉编译工具链配置 编译 关于如何编译，请参阅RMU3.0源码目录下的README.md文件。 运行 运行RMU需要把如下文件置于运行环境的合理位置： RMU主程序； 运行RMU所需的动态库：这通常是由系统工程师负责提供的，关于具体需要哪些动态库，请参阅源码目录下的README.md文件； 配置数据库：这是在编译时生成的，通常命名为config_xxx.db； 完毕之后，通过如下命令运行RMU： $ ./rmu [options] 其中[options]可以为以下选项： 选项 说明 -r 把日志输出到std_err，通常需要这个选项 -v 输出debug信息，如果需要更详细的调试信息，打开这个选项 -c 指定配置数据库文件名 -p 指定配置数据库路径 -h 打印帮助信息 "},"abstract/config_files.html":{"url":"abstract/config_files.html","title":"配置文件","keywords":"","body":"配置文件 配置文件 配置文件的存放位置 .sqlite和.db 查看配置数据库 查看配置数据库母版(.sqlite) 查看某一特定的配置数据库(.db) 修改配置数据库 修改配置数据库母版(.sqlite) 修改某一特定的配置数据库(.db) 配置文件的存放位置 配置文件位于源码目录下的configs目录。对于一个项目，可能存在一个以上的配置，因此在configs目录下，有一个或以上的二级目录用于存放配置文件： configs/ └── config_example └── config_example.sqlite .sqlite和.db RMU3.0与RMU框架相比的一个较大区别，是舍弃了以前的XML配置文件，而改用配置数据库。数据库有如下好处： 管理方便，一个数据库内可以有多个配置表，省去了管理多个文件的麻烦 安全性高，与文件操作相比，失败时不会造成全部配置项损毁 RMU3.0的配置数据库采用SQLite3，.sqlite文件为数据库的母版，可以理解为数据库的可读形式。在编译时，会将.sqlite文件转换为数据库文件.db，从而真正被RMU使用。 Note: 编译时，需要编译机上安装sqlite3工具，否则无法将.sqlite转换成.db。 Note: 在文档的其它部分，将会混用配置文件和配置数据库这两个概念。读者应能完全明白它们之间的等价关系。 查看配置数据库 任何可以打开SQLite3数据库的工具都可用于查看配置数据库内容，要看懂或者修改配置项，开发者应掌握最简单的SQLite语句知识，或者参照给出的说明和示例进行一些依葫芦画瓢的举动。在此列举几种可能用到的手段： 查看配置数据库母版(.sqlite) 直接使用编辑器打开.sqlite文件，即可查看配置数据库的内容。例如： $ cat configs/config_example/config_example.sqlite PRAGMA foreign_keys=OFF; BEGIN TRANSACTION; -- Table Config: includes all config of rmu. KEY_VAL must be unique. CREATE TABLE IF NOT EXISTS \"Config\"( [KEY_VAL] TEXT NOT NULL UNIQUE, [VALUE] TEXT); INSERT INTO Config VALUES('basic.loop_names','main,can,rild'); INSERT INTO Config VALUES('basic.rmu_id','0'); INSERT INTO Config VALUES('GpsTest.uart_path','/dev/ttyLP4'); -- Table ModuleConfig: includes module config for rmu. -- TYPE: should match the string used in module cc file's REGISTER_RTU_MODULE() macro. -- NAME: the name of module. Must be unique. -- LOOP: name of loop this module is running in. Should match one of \"basic.loop_names\" in table Config. -- ACTIVE: 0 means the module is disabled and won't be loaded by rmu framework. CREATE TABLE [ModuleConfig]( [TYPE] TEXT NOT NULL, [NAME] TEXT NOT NULL UNIQUE, [LOOP] TEXT NOT NULL, [ACTIVE] INT NOT NULL DEFAULT 0); INSERT INTO ModuleConfig VALUES('MatrixLink','MTL','main',1); INSERT INTO ModuleConfig VALUES('TestModule','Test1','main',1); INSERT INTO ModuleConfig VALUES('TestModule','Test2','rild',1); INSERT INTO ModuleConfig VALUES('GpsTest','GpsTest','main',1); COMMIT; 可以看到数据库中有两张表：Config和ModuleConfig，配置分别是： CREATE TABLE IF NOT EXISTS \"Config\"( [KEY_VAL] TEXT NOT NULL UNIQUE, [VALUE] TEXT); CREATE TABLE [ModuleConfig]( [TYPE] TEXT NOT NULL, [NAME] TEXT NOT NULL UNIQUE, [LOOP] TEXT NOT NULL, [ACTIVE] INT NOT NULL DEFAULT 0); 这是RMU3.0必需的两张配置表，其余的配置表，可以由开发者自行添加使用。 对表Config的每一列说明如下： 属性 说明 KEY_VAL 文本，非空，主键，表示配置项的名称。建议使用\".\"做适当的分类，例如\"base.rmu_id\" VALUE 文本，表示配置项的具体值 关于表ModuleConfig，请参考Module部分。 查看某一特定的配置数据库(.db) 要从数据库母版生成数据库文件(.db)，需要经过编译过程，参考源码目录下的README.md。 或者你可以这样手动生成一个数据库： $ sqlite3 output.db 要查看一个配置数据库中的内容，可以使用专门的SQLite管理工具，例如SQLite Expert。 对于使用VSCode编辑器的开发者，可以安装SQLite插件，从而在VSCode中直接打开数据库查看内容。 修改配置数据库 对于以前使用的XML文件而言，修改配置是直观的：直接编辑XML文件里的内容即可，但对于数据库而言，修改配置过程或许没有想象中愉快。这是一种妥协：为了使用数据库的强大功能，就不得不忍受它的不便利之处。 修改配置数据库母版(.sqlite) 当需要修改当前项目的默认配置的情况下，可以直接修改配置数据库的母版文件，例如要新增一个配置项，把4G的APN数量配置为2，可以在母版文件中新增一行： INSERT INTO Config VALUES('rild.apn_number', '2'); 修改某一特定的配置数据库(.db) 有些情况下，需要对某一特定的配置数据库做更改，例如对某一块板子做特定配置。这种情况通常发生在板端环境，最好的方法是用sqlite3工具直接在命令行执行SQLite语句对数据库内容进行变动。 或者，如果你对SQLite语句很不熟悉，害怕执行了错误的语句损坏数据库，我建议（最好还是要熟悉SQLite）先把.dbdump出来： $ sqlite3 config_example.db .dump > config_example.sqlite 对sqlite文件进行修改后，再使用命令将其恢复为.db数据库： $ sqlite3 config_example.db 另外，VSCode编辑器的SQLite插件也支持对数据库执行SQLite语句。 "},"modules/define_a_module.html":{"url":"modules/define_a_module.html","title":"定义module","keywords":"","body":"定义Module 定义Module 新增module文件 .h文件 .cc文件 修改配置数据库 在RMU3.0中，module是功能划分的基本单元。一个module即是一个class，它有如下特点： public继承class RtuModule 不可拷贝 构造函数和析构函数均为空，初始化和反初始化在init()和deinit()接口中完成 定义一个新的module遵循以下步骤： 新增module文件 要新建一个module，应在include/modules和src/modules目录中分别增加对应的.h和.cc文件，例如： include/modules/ ├── sys └── test_module.h src/modules/ ├── sys └── test_module.cc sys目录用于存放系统module，这是与框架运行相关的基础模块，一般情况下，开发者不须关心。 .h文件 要完成基础的module构建，需要在.h文件中包含如下内容： #include \"rtu/rtu_module.h\" namespace rmu { class TestModule : public RtuModule { STANDARD_RTU_MODULE(TestModule); }; } // namespace rmu 所有的module都必须定义在namespace rmu中； 所有的module都必须以public方式继承class RtuModule； 借助STANDARD_RTU_MODULE(module_name)宏，可以快捷定义module的构造、析构、init()、deinit()等必备接口； .cc文件 还需要在.cc文件中包含如下内容： #include \"modules/test_module.h\" namespace rmu { int TestModule::init() { return kRetOK; } void TestModule::deinit() { } } // namespace rmu REGISTER_RTU_MODULE(TestModule) init()和deinit()是module的初始化和反初始化函数，必须存在实现，函数内容可以为空（如果你没有需要初始化的东西）； REGISTER_RTU_MODULE(module_name)宏是用于注册module到RMU框架的，使用时注意此宏不应写在namespace rmu中； 修改配置数据库 最后，可以在配置文件中增加关于此模块的配置。关于配置文件的基础知识，请参阅\"配置文件\"一节。 我们要将module的配置加到配置数据库的ModuleConfig表中，关于此表格的每一列，说明如下： 属性 说明 TYPE 文本，非空，表示module的类型，应和某一个module的类名完全一致 NAME 文本，非空，主键，表示module的名字，仅用于作为module的独特id，无其他作用 LOOP 文本，非空，表示module运行在哪个loop，应与配置项中的\"basic.loop_names\"中的某一个loop名完全一致 ACTIVE 整型，非空，表示该module是否要在运行时加载，非0为加载 要添加一个新的模块，在配置文件中插入类似这样的一行： INSERT INTO ModuleConfig VALUES('TestModule','Test1','main',1); 至此，一个新的module添加完成。 "},"modules/init_and_deinit.html":{"url":"modules/init_and_deinit.html","title":"初始化和反初始化","keywords":"","body":"初始化和反初始化 初始化和反初始化 init()接口 deinit()接口 module的初始化和反初始化过程 init()接口 在module加载时，会执行初始化过程，具体为执行该module的init()函数。 你可以在init函数中执行自身的初始化过程，例如： TestModule.h class TestModule : public RtuModule { STANDARD_RTU_MODULE(TestModule); private: char *_data; int *_sock; }; TestModule.cc int TestModule::init() { _sock = -1; _data = new char[256]; return kRetOK; } 要注意的是： init()函数中不可发送event、data，在init()函数中发送event或者data会造成未知结果，且肯定不会正确地发送到所有接收端； init()函数不应该长时间阻塞，否则会影响其他module的初始化过程； 如果初始化成功，返回kRetOK，否则返回任意的kErrXXX，这会让框架放弃此模块的加载。要注意，此种情况下不会执行deinit()； deinit()接口 同样道理，在module被销毁（通常是程序结束执行，或者遇到信号异常退出）时，会执行deinit()函数。 你应该在deinit()函数中销毁所有由自己管理的资源，例如： TestModule.cc void TestModule::deinit() { delete _data; } 要注意的是，deinit()函数不可长时间阻塞，否则会影响程序的正常退出。如果在deinit()函数中的某项操作可能失败，应设定一个最大的尝试次数，而不是一直重复尝试。 module的初始化和反初始化过程 每次RMU启动加载模块的时候，若使用的是同一份配置，则初始化函数的执行顺序是固定的，但不要试图利用这一点。 同理，销毁的顺序也是固定的。 初始化和反初始化过程均为单线程执行： 若初始化过程开始，主线程首先会顺序加载所有的module，并对其进行初始化，然后再展开业务线程； 若反初始化过程开始，框架首先会通知主线程，主线程（试图）回收所有的业务线程，然后进行反初始化过程； "},"modules/add_function.html":{"url":"modules/add_function.html","title":"为module添加功能","keywords":"","body":"为module添加功能 为module添加功能 module包含的功能 module的私有成员 私有成员的安全性 module包含的功能 当你在你自定义的模块中包含rtu/rtu_module.h头文件并正确声明了module时，你已经为module包含了如下基本功能： event timer fd watcher log config manager 你可以直接使用这些功能而无须引入额外的头文件。 参阅对应的章节以获取关于这些基本功能的更多信息。 module的私有成员 一般情况下，应该把所有的module成员变量和成员函数声明为private。 对于非类成员函数，应加上static关键字以限制其作用域。 反对在module的.cc文件中定义全局变量。除非你很确定这个module不会被生成一个以上的实例，否则使用全局变量是几乎一定会出问题的。将所有东西放在类中是最安全的做法。 私有成员的安全性 把成员变量或成员函数声明为private，可以避免其它类意外访问它们，但并不意味着它们是完全密封的。 对于timer、event等机制的回调函数，即使声明其为private，也会被框架正确调用，你不应该因此而产生担心。 具体的实现方案，请参阅std::function和std::bind。 "},"watchers/timer.html":{"url":"watchers/timer.html","title":"timer","keywords":"","body":"timer timer timer组件 创建和释放timer 启动和停止timer timer的实现 timer组件 timer定时器，给定一个回调函数及时间间隔，框架将在时间间隔后调用回调函数。 timer属于module的基础组件，不须包含额外的头文件即可使用。 RMU3.0框架中包含两种基本类型的timer： 一次性timer：在给定的时间间隔后调用回调函数； 重复timer：在给定的时间间隔后调用回调函数，并且每经过一定的周期自动调用回调函数； 创建和释放timer 可以这样定义一个timer： test_module.h class TestModule : public RtuModule { STANDARD_RTU_MODULE(TestModule); private: void TestTimerCB(); Watcher *_test_timer; }; test_module.cc void TestModule::TestTimerCB() { dbg(\"timer callback\"); } int TestModule::init() { init_timer(_test_timer, TestModule::testTimerCB, 1000); return kRetOK; } void TestModule::deinit() { if (_test_timer) delete _test_timer; } 为了保存timer的实体，需要有一个Watcher*指针变量，Watcher是timer、event_watcher、fd_watcher的共同基类。 通过使用宏： init_timer(watcher, callback, after) 来快速创建一个一次性timer，其中，watcher为Watcher*变量，callback是timer的回调函数，具有void (*f)(void)的形式，after是timer启动到回调函数被调用的时间间隔，单位为ms。 回调函数必须是某一module的成员函数。此函数本身没有任何特殊的地方，可以声明为public或者private，都不影响框架正确调用它。此函数也可以像一个正常的成员函数一样，访问module本身的任何私有成员。 除了一次性timer，也可以使用宏： init_repeat_timer(watcher, callback, after, repeat) 来创建重复timer，其中repeat是回调函数被调用的周期，其它参数含义与init_timer()完全相同。 启动和停止timer 当timer被创建完毕后，可以在module的任意位置使用Start()接口启动，或者使用Stop()接口停止。 _test_timer->Start(); _test_timer->Stop(); 这两个函数均可重复调用，如果在timer已经start的情况下继续调用Start()，或者在已经stop的情况下继续调用Stop()，均不会有任何动作。 timer的实现 timer的实现基于libev提供的ev_timer组件，具体请参阅libev的相关文档。 "},"watchers/fd_watcher.html":{"url":"watchers/fd_watcher.html","title":"fd_watcher","keywords":"","body":"fd_watcher fd_watcher fd_watcher组件 创建和释放fd_watcher 启动和停止fd_watcher fd_watcher的实现 fd_watcher组件 和timer类似，fd_watcher组件也包含在module的基本功能中，无须包含额外的头文件即可使用。 fd_watcher，顾名思义是监控文件描述符的组件。在RMU3.0中，fd_watcher有且仅有一种用法，即给定要监控的文件描述符和回调函数，在该文件描述符指向的文件可读时，调用回调函数。 创建和释放fd_watcher 可以这样定义一个fd_watcher： test_module.h class TestModule : public RtuModule { STANDARD_RTU_MODULE(TestModule); private: void TestFdCB(int); Watcher *_test_fd_watcher; }; test_module.cc void TestModule::TestFdCB(int fd) { dbg(\"fd watcher callback\"); } int TestModule::init() { int fd = open(...); init_fdwatcher(_test_fd_watcher, TestModule::TestFdCB, fd); return kRetOK; } void TestModule::deinit() { if (_test_fd_watcher) delete _test_fd_watcher; } 为了保存fd_watcher的实体，需要有一个Watcher*指针变量，Watcher是timer、event_watcher、fd_watcher的共同基类。 通过使用宏： init_fdwatcher(watcher, callback, fd) 来快速创建一个fd_watcher，其中，watcher为Watcher*变量，callback为回调函数，具有void (*f)(int)的形式，fd为要监控的文件描述符。 回调函数必须是某一module的成员函数。此函数本身没有任何特殊的地方，可以声明为public或者private，都不影响框架正确调用它。此函数也可以像一个正常的成员函数一样，访问module本身的任何私有成员。 回调函数只有一个int参数，即该回调函数对应的文件描述符。 大部分有时候，我们愿意把fd_watcher的初始化放在module的init()过程中，而此时，要监控的fd不一定已知。在这种情况下，可以使用-1作为文件描述符来初始化fd_watcher，在获取真正要监听的fd之后使用Listen()接口来绑定新的fd，例如： (reinterpret_cast(_test_fd_watcher))->Listen(fd); 启动和停止fd_watcher 当fd_watcher被创建完毕后，可以在module的任意位置使用Start()接口启动，或者使用Stop()接口停止。 _test_fd_watcher->Start(); _test_fd_watcher->Stop(); 这两个函数均可重复调用，如果在timer已经start的情况下继续调用Start()，或者在已经stop的情况下继续调用Stop()，均不会有任何动作。 fd_watcher的实现 和timer类似，fd_watcher也是基于libev提供的组件ev_io实现。具体细节读者可以参阅libev的相关文档。 值得注意的是： ev_io本身提供两种监控功能，即可读时回调或可写时回调，在RMU3.0框架中，只使用了可读回调，这已经覆盖了文件描述符监控的一般场景； ev_io有时候会“误报”，也即回调函数被调用时，实际上并没有可读数据，开发者需要细心设计回调函数的内容以处理这种情况； 根据libev编程的指导思想，也即所有回调函数都不能长时间阻塞，强烈建议把被监控的文件描述符设为非阻塞方式读取。 "},"watchers/event/create_and_send_event.html":{"url":"watchers/event/create_and_send_event.html","title":"创建和发送event","keywords":"","body":"创建和发送event 创建和发送event event的创建 在event.h中新增event描述 在events.cc中注册event event的发送 event创建和发送的实现 event的创建 event是module之间用于通信的机制，具有如下特点： 一个发送者，多个接收者； 可以携带数据，也可以不携带，只单纯通知，类似于信号； RMU3.0中的event基本沿用了旧框架的机制，任意的module都可以发送事先注册到框架中的event，并通过event_watcher组件监听接收特定的event。 event的相关文件位于include/events及src/events目录，要创建一个新的event，需要经过如下步骤： 在event.h中新增event描述 在RMU3.0中，定义了几种类型的事件，对于一般开发者而言，会用到如下两种类型： module event - 用于module通信的一般事件，不携带数据，只作为通知使用； module complex event - 用于module通信的复合事件，携带数据； 无论是新增一个一般event还是复合event，都需要在include/events/events.h中的对应位置新增一个事件ID： events.h enum ModuleEventIds { kEventModuleMin, /* Add new events below */ kEventTest1, /* sentinel */ kEventModuleMax }; enum ModuleComplexEventIds { kEventModuleComplexMin, /* Add new events below */ kEventTest2, /* sentinel */ kEventModuleComplexMax }; struct EventTest2 { double sign; int k; }; 其中，如果是一般event，直接在enum ModuleEventIds中新增一个ID即可；如果是复合event，除了在enum ModuleComplexEventIds中新增一个ID之外，还需要新增一个结构体描述，作为此event携带的数据结构。 对于复合event的id及其携带的结构体，强烈建议其命名具有统一形式，例如kEventFoo和struct EventFoo，但这并非硬性要求。 此外，如果结构体涉及到深拷贝，开发者需要重载结构体的operator=，例如： struct EventTest2 { EventTest2& operator=(const EventTest2 &e) { /* copy here */ } }; 在涉及深拷贝的情况下，通常也要求结构体包含显式的析构函数，以正确管理内存。 在events.cc中注册event 在src/events/events.cc中，需要把此前新增的事件注册到框架： events.cc REGISTER_EVENT(kEventTest1); REGISTER_COMPLEX_EVENT(kEventTest2, EventTest2); 使用宏REGISTER_EVENT(event_id)来注册一个一般event； 使用宏REGISTER_COMPLEX_EVENT(event_id, event_data_type)来注册一个复合event，其中event_data_type是指event要携带的数据体类型； 至此，event创建完成。 event的发送 在module除了init()和deinit()外的任意位置，都可以调用SendEvent()接口来发送事件： EventTest2 ev_data; /* sending module event */ SendEvent(kEventTest1); /* sending module complex event */ SendEvent(kEventTest2, &ev_data); SendEvent()调用结束后，复合event的数据，也即上例中的ev_data就不再使用，可以自由处理。 event创建和发送的实现 关于此话题，请参阅“event收发模型”一节。 "},"watchers/event/event_watcher.html":{"url":"watchers/event/event_watcher.html","title":"event_watcher","keywords":"","body":"event_watcher event_watcher event_watcher组件 创建和释放event_watcher 启动和停止event_watcher event_watcher的实现 event_watcher组件 event_watcher是module提供的基本组件之一，无须引入额外的头文件即可使用。 event_watcher为module提供监听特定event的能力，给定一个event id及回调函数，当有其它module发送该event时，回调函数就会被调用。 创建和释放event_watcher 可以这样定义一个event_watcher： test_module.h class TestModule : public RtuModule { STANDARD_RTU_MODULE(TestModule); private: void EventTest1CB(int, void*); Watcher *_test_ev_watcher; }; test_module.cc void TestModule::EventTest1CB(int id, void *data) { dbg(\"event callback\"); } int TestModule::init() { init_evwatcher(_test_ev_watcher, TestModule::EventTest1CB, kEventTest1); return kRetOK; } void TestModule::deinit() { if (_test_ev_watcher) delete _test_ev_watcher; } 为了保存event_watcher的实体，需要有一个Watcher*指针变量，Watcher是timer、event_watcher、fd_watcher的共同基类。 通过使用宏： init_evwatcher(watcher, callback, event_id) 来快速创建一个event_watcher，其中，watcher为Watcher*变量，callback是event_watcher的回调函数，具有void (*f)(int, void*)的形式，event_id是要监听的event的ID，详见“创建和发送event”一节。 回调函数必须是某一module的成员函数。此函数本身没有任何特殊的地方，可以声明为public或者private，都不影响框架正确调用它。此函数也可以像一个正常的成员函数一样，访问module本身的任何私有成员。 event_watcher的回调函数具有2个参数，int参数为event id，void*为该event携带的数据地址，可以使用reinterpret_cast`来对其进行访问： void TestModule::EventTest1CB(int id, void *data) { EventTest1 *ev_data = reinterpret_cast(data); if (ev_data) { ev_data->... } } 该数据无须在回调函数中销毁，亦不应被改动，你也可以使用宏to_event_data(data, type)宏来快速获取event的数据，例如： auto ev_data = to_event_data(data, EventTest1); 启动和停止event_watcher 当timer被创建完毕后，可以在module的任意位置使用Start()接口启动，或者使用Stop()接口停止。 _test_ev_watcher->Start(); _test_ev_watcher->Stop(); 这两个函数均可重复调用，如果在timer已经start的情况下继续调用Start()，或者在已经stop的情况下继续调用Stop()，均不会有任何动作。 event_watcher的实现 ev_watcher的实现请参阅“event收发模型”一节。此前已经提到过，对于event，基本继承了旧框架的实现方案，对于熟悉旧框架的开发者来说，他们的经验依然有效。 event_watcher收不到module自身发出的event，这适用于module event和module complex event。 对于event id比较熟悉的开发者会发现，如果event id中包含了LoopBack特性，那么这个event就可以被注册了合适event_watcher的module自发自收。诚然，这并不是一个多么有用的特性。 "},"watchers/event/event_trans_model.html":{"url":"watchers/event/event_trans_model.html","title":"event收发模型","keywords":"","body":"event收发模型 event收发模型 TODO "},"watchers/event/matrix_link.html":{"url":"watchers/event/matrix_link.html","title":"跨进程event","keywords":"","body":"跨进程event 跨进程event 跨进程event组件 公共event的创建 Module MatrixLink 公共event的发送和接收 公共event收发模型 跨进程event组件 跨进程event是RMU3.0框架中的一个新特性，它扩展了event的传播范围，使得一个event不仅仅可以在RMU3.0的module之间传播，还可以被其它同样运行RMU3.0框架的进程接收。 对于RMU，一个基本的认知是它包含许多的module，每个module负责不同的功能模块。显然，不同的功能之间稳定性、重要程度、耦合度是不一样的，例如管理网络连接的module稳定性几乎肯定要强于采集视频的module。 这促使我们思考如何避免一个不稳定的module影响原本稳定的module——在module运行出现问题时，几乎一定会导致整个进程的崩溃。那么显然的解法是划分多个线程，每个线程运行一组功能相关的module，例如一种最简单的划分方式，一个进程负责基础系统功能保障——网络、核间通信、电源管理等，另一个进程负责业务逻辑——计算、采集、处理。 那么多个进程之间一定要有一种互相通信的方式，这种方式应该具有以下特点： 高效，不复杂； 只携带极少量数据——对于涉及大量数据交互的module，毫无疑问应该放在同一个进程中，这样他们可以高效地共享数据； 对于一般开发者，使用起来应该尽可能简便； 跨进程event正是基于以上的考虑而诞生的新组件。它使用了共享内存，在RMU3.0进程之间高效地（只是相对的，尽管我这么说，你仍然不应该让跨进程event携带大量数据）收发事件，它有如下特性： 自动注册和反注册：当RMU启动时，自动地寻找当前已经启动的其它RMU进程，并建立通信；自动地处理其它RMU进程的加入和离开； 划分私有event和公共event：如果你希望这个event被跨进程传播，或者不希望，都是可以做到的； 使用便利，和一般的event没有任何区别； 它还存在如下问题： 不具备用跨进程event传输大量数据的能力； 不同RMU进程之间的公共event列表需要统一，意味着需要跨项目维护一两个文件； 公共event的创建 公共event是指用于跨进程传播的event。如果你在module内发送了一个公共event，那么它将传播到系统中所有的RMU3.0进程；如果你在module内监听了一个公共event，那么也能收到从别的RMU3.0进程发来的该event。 创建公共event和创建一个普通event没有什么区别，但要注意的是你需要将event创建在public/public_events.h和public/public_events.cc中。例如： public_events.h enum PublicEventIds { kPublicEventMin, /* Add new events below */ kPEventTest, /* sentinel */ kPublicEventMax }; struct PEventTest { double sign; int k; }; public_events.cc REGISTER_PUBLIC_EVENT(kPEventTest, PEventTest); 要注意，公共event全部都携带有一个数据体，而不存在类似于module event这样不携带数据体的分类。 Module MatrixLink MatrixLink是RMU3.0的一个特殊module，它为RMU3.0提供跨进程通信能力。 在配置文件中把MatrixLink打开，RMU3.0就将具备跨进程收发event的能力，对于每一个参与跨进程通信的RMU3.0进程，都需要打开这个module。 INSERT INTO ModuleConfig VALUES('MatrixLink','MTL','main',1); 反之，如果一个RMU3.0进程不希望参与到公共event的收发中，那么只需要把MatrixLink关掉即可。 公共event的发送和接收 对于module开发者来说，要收发公共event，只需要像普通的module event收发一样： 使用SendEvent()接口发送event 使用event_watcher组件接收event 要注意和上一小节区分的是，无论MatrixLink是否打开，公共event都可以在进程内部传播，而一旦打开了MatrixLink，公共event就会传播到其它RMU3.0进程。 公共event收发模型 公共event的实现可以由如下框图概括： MatrixLink由两个线程和一块共享内存构成。thread 1也即MatrixLink本身所在的Loop，会自动注册event_watcher监听所有的public event，当一个public event发送给MatrixLink时，将其放进共享内存中，并通知其它在监控这个共享内存的RMU进程取走该event；thread 2为监控线程，平时等待其它进程将其唤醒，一旦被唤醒，将尝试从监控的RMU进程中获取public event，并在进程内部分发。 进程之间相互唤醒，是通过共享内存中的一个信号量实现的。 除了信号量，每个MatrixLink还持有： 一个共享内存中的互斥锁，用于保护共享内存相关的状态变量，避免进程之间的竞态； 一个普通互斥锁，用于保护MatrixLink内部变量，避免thread 1和thread 2之间的竞态； "},"watchers/data/create_and_send_data.html":{"url":"watchers/data/create_and_send_data.html","title":"创建和发送data","keywords":"","body":"创建和发送data 创建和发送data data组件 data queue的创建 添加data queue描述 注册data queue data的发送 引入data_writer组件 Get buffer操作 Put buffer操作 data创建和发送的实现 data组件 data组件是RMU3.0中的一个新特性。众所周知，要在旧RMU软件中传递数据，比较常用也是几乎唯一的方法，就是通过event。然而event底层的实现又决定了它不适合用来传输大量数据：每有一个新的loop加入特定event的监听行列，就意味着该event在传输时需要多复制一个副本。 而且，在proc/module->rtu_module的兼容层中，也存在不合理的内存拷贝。 而随着RMU功能的不断扩展，传输数据量会越来越大，性能要求也会越来越严格。 data组件正是基于以上考虑而诞生的新组件。它为module之间提供一种近乎于（为什么是近乎于，参见“data收发模型”一节）零拷贝的数据传输手段。通过它来收发数据，可以获得比event更高的理论性能。 它有如下特点： 适用于传输大量数据：对于少量数据，使用event即可满足需求； 没有event易用：要真正实现数据传输过程的零拷贝，除了data组件自身提供的实现保障，开发者必须小心处理，避免由自己写出更多的内存拷贝； 不含在module的默认组件中，需要使用时开发者要自己引入data组件的相关头文件； 最后，虽然这里称其为data组件，但实际上它是由几个部分组成，分别是： data_writer：用于发送数据； data_queue：用于数据中继； data_watcher：用于接收数据； 对于一般的开发者而言，data_queue组件是几乎透明的（这个概念只会在创建data时昙花一现），我们只需关心如何使用data_writer发送数据和使用data_watcher接收数据。 data queue的创建 data queue是指用于承载data的结构，当我们要发送数据时，首先要做的是静态地创建一个data queue，这和创建event的道理是一样的。 data queue是一个类似队列的结构，一个data queue由数量固定的blocks组成，每个block具有固定的大小。收发数据时的基本单位是block，也即我们每次发送一个block的数据，或接收一个block的数据。 data queue的相关文件位于include/events及src/events目录中，通过如下步骤，创建一个新的data queue： 添加data queue描述 有两种描述data queue的方式： 提供data queue的名称、block的结构（一个struct描述）、block数量； 提供data queue的名称、block的大小、block数量； 两种方式声明的data queue在本质上无任何不同。 在include/events/dataqs.h中这样描述data queue： dataqs.h enum DataQIds { kDataQIdMin, /* Add new data queues below */ kDataTest1, kDataTest2, /* sentinel */ kDataQIdMax }; struct DataTest1 { uint32_t length; uint8_t buf[512]; }; 和描述event几乎一样。强烈建议如果使用上述的第1.种方式声明data queue时，保持结构体和data queue id命名的统一性。 注册data queue 添加了data queue的描述之后，在src/events/dataqs.cc中需要注册这个data queue，例如： dataqs.cc REGISTER_DATA_Q(kDataTest1, DataTest1, 10); REGISTER_FREE_DATA_Q(kDataTest2, 256, 15); 使用宏REGISTER_DATA_Q(dataq_id, data_struct_type, block_number)来注册一个id为dataq_id、含有block_number个block、每个block具有data_struct_type形式的data queue； 使用宏REGISTER_FREE_DATA_Q(dataq_id, block_size, block_number)来注册一个id为dataq_id、含有block_number个block、每个block大小为block_size的data queue； data的发送 发送data可以分为三个步骤： 从data queue请求buffer； 向buffer写入要发送的数据； 把buffer归还给data queue； 引入data_writer组件 要在module中发送数据，需要引入data_writer组件： test_module.h #include \"common/data_writer.h\" #include \"events/dataqs.h\" ... class TestModule : public RtuModule { STANDARD_RTU_MODULE(TestModule); private: DataWriter _writer; }; test_module.cc int TestModule::init() { _writer.Claim(this, kDataTest1, kNotLeaky); return kRetOK; } 要发送data，首先需要将data_writer绑定到某个特定的data_queue。这通常是在init()中通过Claim()接口来实现的，要注意的是，一个data queue只能有一个writer。 Get buffer操作 要发送数据，首先要请求buffer，使用GetBuffer()接口： void *buffer = _writer.GetBuffer(); /* writer some data to buffer */ /* ... */ 注意这里获取的buffer位置是一个无保护的void指针，写入数据时要特别注意内存溢出问题，强烈建议使用结构体来规整写入，例如： auto buffer = reinterpret_cast(_writer.GetBuffer()); Put buffer操作 在写入数据之后，调用PutBuffer()接口，将buffer归还给data queue，与此同时，data queue会将数据发送给所有接收方。 _writer.PutBuffer(buffer); data创建和发送的实现 有关这部分内容，请参阅“data收发模型”一节。 "},"watchers/data/data_watcher.html":{"url":"watchers/data/data_watcher.html","title":"data_watcher","keywords":"","body":"data_watcher data_watcher data_watcher组件 创建和释放data_watcher 启动和停止data_watcher data_watcher的实现 data_watcher组件 data_watcher是专用于监听data queue数据的组件。data_watcher不是module默认包含的组件，如果要使用，需要引入额外的头文件。 创建和释放data_watcher 可以这样定义一个data_watcher： test_module.h #include \"common/data_watcher.h\" ... class TestModule : public RtuModule { STANDARD_RTU_MODULE(TestModule); private: DataWatcher *_data_watcher; }; test_module.cc void TestModule::DataTest1CB(int id, void *data) { dbg(\"data callback\"); } int TestModule::init() { init_datawatcher(_data_watcher, TestModule::DataTest1CB, kDataTest1); return kRetOK; } void TestModule::deinit() { if (_data_watcher) delete _data_watcher; } 你可能会发现其用法和event_watcher非常相似，除了需要明确地将储存data_watcher的指针类型声明为DataWatcher*之外。因为DataWatcher并不是以Watcher作为基类的。 通过使用宏： init_datawatcher(watcher, callback, dataq_id) 来快速创建一个data_watcher，其中，watcher为DataWatcher*变量，callback为data_watcher的回调函数，具有void (*f)(int, void*)的形式，dataq_id为要监听的data queue的ID，详见“创建和发送data”一节。 回调函数必须是某一module的成员函数。此函数本身没有任何特殊的地方，可以声明为public或者private，都不影响框架正确调用它。此函数也可以像一个正常的成员函数一样，访问module本身的任何私有成员。 data_watcher的回调函数具有2个参数，int参数为dataq id，void*为数据地址，可以使用reinterpret_cast`来对其进行访问： void TestModule::DataTest1CB(int id, void *data) { auto buffer = reinterpret_cast(data); ... } 实际上，为了保持易用性，data_watcher跟event_watcher回调的使用方法是一致的，你也可以用to_event_data()宏来快速获取描述data的结构体。 启动和停止data_watcher 为了保持易用性，data_watcher的启停方式和event_watcher是一致的，都是通过Start()和Stop()接口。 data_watcher的实现 data_watcher实际上是基于event_watcher来实现的，这就是为什么说data queue是一种“近乎于”零拷贝的机制——其数据部分是零拷贝的，但为了对监听者们进行广播通知所使用的event不是零拷贝的。 有关于data_watcher实现更深层的内容，请参考“data收发模型”一节。 "},"watchers/data/data_trans_model.html":{"url":"watchers/data/data_trans_model.html","title":"data收发模型","keywords":"","body":"data收发模型 data收发模型 TODO "},"other_components/log.html":{"url":"other_components/log.html","title":"日志功能","keywords":"","body":"日志功能 日志功能 使用日志功能 日志功能的实现 使用日志功能 RMU3.0提供基本的日志输出功能，只需包含如下头文件，即可使用日志功能： #include \"old/log.h\" 对于module开发者来说，log功能是包含在module的基本组件中的，无须手动引入头文件。 RMU3.0提供分级别控制的日志输出，各个级别使用的接口、用途分别为： Log API Note crit Critical：会导致RMU不得不退出的错误信息 err Error：会影响RMU业务功能正常运行的错误信息 warn Warning：不应该出现但是不影响业务功能正常运行的错误信息 msg Info：正常运行过程中输出的提示信息 dbg Debug：正常运行时不打印的详细调试信息 上表列出的API用法和printf一样，例如： dbg(\"this is a debug msg for id %d\", id); 注意，无须手动添加换行符。 在实际输出时，框架会为日志信息添加事件、软件名、进程ID、日志所处的代码文件名称和行号等信息。 日志功能的实现 日志功能继承了RMU旧框架的log模块，未作太多的改动。 "},"other_components/config_rw.html":{"url":"other_components/config_rw.html","title":"配置读写","keywords":"","body":"配置读写 配置读写 config_manager组件 读写配置项 config_manager组件 config_manager是包含在module中的标准组件，提供读写配置文件（数据库）的功能。如果开发者希望在module开发以外的环境使用config_manager，则需要包含如下头文件： #include \"common/config_manager.h\" 通过如下接口来获取config_manager的实体： ConfigManager &conf_mgr = ConfigManager::GetConfigManager(); 这里应该显式地使用ConfigManager&类型，而非auto。 读写配置项 一旦获取了config_manager的实体，就可以通过GetValue()来获取配置项的值，或是通过SetValue()来设置配置项的值，例如： std::string value; if (conf_mgr.GetValue(\"basic.loop_names\", value) == kRetOK) { value += \",test_loop\"; conf_mgr.SetValue(\"basic.loop_names\", value); } else { err(\"failed to get loop names\"); } GetValue()和SetValue()均有多个重载，用于实现不同类型变量的配置读/写，具体请参阅config_manager.h。 "},"other_components/string_handling.html":{"url":"other_components/string_handling.html","title":"字符串处理","keywords":"","body":"字符串处理 字符串处理 关于octstr的可替代性讨论 Estring 关于octstr的可替代性讨论 RMU3.0中并没有专门设计一个类似于旧RMU框架中的octstr类。诚然，octstr本身是一个可靠而高性能的字符串实现，而且集合了许多有用的字符串处理功能，但它的缺点也很明显： 需要特别注意申请和释放，开发者往往迷失在一堆跟octstr有关的API调用中，从而分不清哪些需要释放，哪些不需要；根据经验，这起码是50%旧RMU程序中的内存泄露的原因。 那么在新框架中，是否还有必要构建一个类似于octstr的类来专用于字符串处理？也许有，但在目前看来，octstr涉及到的所有功能都是可以找到替代品的。 octstr在旧RMU担任的主要功能： 字符串处理，包括格式化生成、分割、拼接等； 生成网络报文字节流； 对于前者，在C++中有一大堆可替代品，例如在RMU3.0中，目前只使用了std::string来装载字符串，它天生就含有： 任意拼接；std::string str1 = \"hello\"; std::string str2 = str1; std::string str3 = str1 + \" and \" + str2; // str3 is \"hello and hello\" 与C风格string的转换；std::string str(\"world\"); dbg(\"%s\", str.c_str()); 通过引入boost::format，我们更可以格式化地生成std::string： #include ... int k = 3; char *s = \"is three\" std::string f = (boost::format(\"%d %s\") % k % s).str(); 而对于生成网络报文，更建议采用结构体的方式： struct data_frame { uint8_t id; ... }__attribute__((aligned)); 一方面可读性更强，二来也避免一些低级的寻址错误。 最重要的是，std::string可以像一个基本变量一样申请和释放，而不需要涉及到指针，这从很大程度上防止了内存泄漏。 当然，它并不是性能最优的字符串，如果开发者面临严苛的字符串处理性能要求，那么使用C风格字符串是更好的选择。 Estring EString即Enhanced String，是RMU3.0中的一个命名空间，包含一些字符串操作函数的集合。 现在，Estring主要提供了字符串分割和十六进制打印功能： vector Split(const string &haystack, const char needle); vector Split(const string &haystack, const string &needle); void HexDump(const unsigned char *buf, size_t size); 其中，EString::Split()是字符串分割函数，EString::HexDump则类似于以前的octstr_dump，提供字符串的十六进制打印功能。 要注意的是，HexDump内含一个互斥锁，会对RMU的并行性能造成严重的影响，非调试场合，请勿轻易使用这个函数。 "},"other_components/lock.html":{"url":"other_components/lock.html","title":"锁","keywords":"","body":"锁 锁 RMU3.0中提供两种类型的锁：mutex_lock互斥锁和rw_lock读写锁。关于这两种锁的区别，请参阅网上资料。 要在RMU3.0中使用锁，需要包含如下头文件： #include \"utils/lock.h\" 你可以这样获取一个锁： Lock *mutex = Lock::GetLock(\"MutexLock\"); Lock *rw_lock = Lock::GetLock(\"RWLock\"); 然后可以使用lock()、unlock()、lock_shared()、unlock_shared()来进行加解锁操作。 对于mutex而言，有无_shared后缀的操作实质并无不同。 "},"other_components/db_operation.html":{"url":"other_components/db_operation.html","title":"数据库操作","keywords":"","body":"数据库操作 数据库操作 TODO "},"other_components/python_runner.html":{"url":"other_components/python_runner.html","title":"Python运行器","keywords":"","body":"Python运行器 Python运行器 TODO "}}